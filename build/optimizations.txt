0. start: 127s
1. no lambdas: 82s
2. removed division and floor/ceil: 65s

  size_t i1 = floor(s / h);
  size_t i2 = ceil(s / h);
->  
  size_t i1 = s / h;
  size_t i2 = i1+1;

3. replace /h by *hInv: 64s

  int is = s * hInv;
  is -= i;

4. remove if branch in N: 56s

  if (s <= (i - 1) * h || s >= (i + 1) * h) {
    erg = 0;
  } else {
    if (s < i * h) {
      erg = (s - (i - 1) * h) * hInv;    // (i-1)*h < s < i*h
    } else {
      erg = ((i + 1) * h - s) * hInv;     // i*h <= s < (i+1)*h
    }
  }

->
  
  double erg = 0;     // falls s < (i-1)*h   or   s > (i+1)*h
  switch (is)
  {
  case -1:
    erg = (s - (i - 1) * h) * hInv;     // falls (i-1)*h < s < i*h
    break;

  case 0:
    erg = ((i + 1) * h - s) * hInv;     // falls i*h <= s < (i+1)*h
    break;

  default:
    break;
  }

5. reuse s * hInv: 51s
erg = (s - (i - 1) * h) * hInv;     // falls (i-1)*h < s < i*h
->
erg = shInv - i + 1;                // falls (i-1)*h < s < i*h

6. remove sanity check in Theta (never hit), replace size_t by int: 46s
